; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	D:\Dropbox\Faks\6. semestar\SP\Projekat\VS\SP-Projekat-Repo\SP Projekat\Emulator\Utility.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_GetOPCode
PUBLIC	_GetInfoFromByte
PUBLIC	_ExtSgn
PUBLIC	_SetFlag
PUBLIC	_ResetFlag
PUBLIC	_GetFlag
PUBLIC	_GetLowerByte
PUBLIC	_GetHigherByte
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_cpu:BYTE
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _GetHigherByte
_TEXT	SEGMENT
_word$ = 8						; size = 2
_GetHigherByte PROC					; COMDAT

; 68   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 69   : 	return GetLowerByte(word >> 8);

	movzx	eax, WORD PTR _word$[ebp]
	sar	eax, 8
	push	eax
	call	_GetLowerByte
	add	esp, 4

; 70   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_GetHigherByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _GetLowerByte
_TEXT	SEGMENT
_mask$ = -32						; size = 2
_b$ = -17						; size = 1
_i$ = -5						; size = 1
_word$ = 8						; size = 2
_GetLowerByte PROC					; COMDAT

; 56   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 57   : 	unsigned char i = 0;

	mov	BYTE PTR _i$[ebp], 0

; 58   : 	UBYTE b = 0;

	mov	BYTE PTR _b$[ebp], 0

; 59   : 	UWORD mask = 1;

	mov	eax, 1
	mov	WORD PTR _mask$[ebp], ax

; 60   : 
; 61   : 	for (i = 0; i < 8; i++)

	mov	BYTE PTR _i$[ebp], 0
	jmp	SHORT $LN3@GetLowerBy
$LN2@GetLowerBy:
	mov	al, BYTE PTR _i$[ebp]
	add	al, 1
	mov	BYTE PTR _i$[ebp], al
$LN3@GetLowerBy:
	movzx	eax, BYTE PTR _i$[ebp]
	cmp	eax, 8
	jge	SHORT $LN1@GetLowerBy

; 62   : 		b += ((mask << i) & word); // nisam siguran kako radi |= za razlicite velicine (byte, word) pa sam stavio +=

	movzx	eax, WORD PTR _mask$[ebp]
	movzx	ecx, BYTE PTR _i$[ebp]
	shl	eax, cl
	movzx	ecx, WORD PTR _word$[ebp]
	and	eax, ecx
	movzx	edx, BYTE PTR _b$[ebp]
	add	edx, eax
	mov	BYTE PTR _b$[ebp], dl
	jmp	SHORT $LN2@GetLowerBy
$LN1@GetLowerBy:

; 63   : 
; 64   : 	return b;

	mov	al, BYTE PTR _b$[ebp]

; 65   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GetLowerByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _GetFlag
_TEXT	SEGMENT
_flag$ = 8						; size = 4
_GetFlag PROC						; COMDAT

; 48   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 49   : 	if (cpu.psw & (1 << flag))

	movsx	eax, WORD PTR _cpu+20
	mov	edx, 1
	mov	ecx, DWORD PTR _flag$[ebp]
	shl	edx, cl
	and	eax, edx
	je	SHORT $LN2@GetFlag

; 50   : 		return ONE;

	mov	eax, 1
	jmp	SHORT $LN3@GetFlag

; 51   : 	else

	jmp	SHORT $LN3@GetFlag
$LN2@GetFlag:

; 52   : 		return ZERO;

	xor	eax, eax
$LN3@GetFlag:

; 53   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GetFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _ResetFlag
_TEXT	SEGMENT
_flag$ = 8						; size = 4
_ResetFlag PROC						; COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 44   : 	cpu.psw &= ~(1 << flag);

	mov	eax, 1
	mov	ecx, DWORD PTR _flag$[ebp]
	shl	eax, cl
	not	eax
	movsx	ecx, WORD PTR _cpu+20
	and	ecx, eax
	mov	WORD PTR _cpu+20, cx

; 45   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_ResetFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _SetFlag
_TEXT	SEGMENT
_flag$ = 8						; size = 4
_SetFlag PROC						; COMDAT

; 38   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 39   : 	cpu.psw |= (1 << flag);

	mov	eax, 1
	mov	ecx, DWORD PTR _flag$[ebp]
	shl	eax, cl
	movsx	ecx, WORD PTR _cpu+20
	or	ecx, eax
	mov	WORD PTR _cpu+20, cx

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_SetFlag ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _ExtSgn
_TEXT	SEGMENT
_i$ = -32						; size = 4
_w$ = -20						; size = 2
_b$ = -5						; size = 1
_byte$ = 8						; size = 1
_numBits$ = 12						; size = 4
_ExtSgn	PROC						; COMDAT

; 25   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 26   : 	UBYTE b = GetInfoFromByte(numBits - 1, 0, byte);

	movzx	eax, BYTE PTR _byte$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _numBits$[ebp]
	sub	ecx, 1
	push	ecx
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _b$[ebp], al

; 27   : 	WORD w = b;

	movzx	ax, BYTE PTR _b$[ebp]
	mov	WORD PTR _w$[ebp], ax

; 28   : 	unsigned int i = 0;

	mov	DWORD PTR _i$[ebp], 0

; 29   : 
; 30   : 	if (w & (1 << (numBits - 1)))

	movsx	eax, WORD PTR _w$[ebp]
	mov	ecx, DWORD PTR _numBits$[ebp]
	sub	ecx, 1
	mov	edx, 1
	shl	edx, cl
	and	eax, edx
	je	SHORT $LN4@ExtSgn

; 31   : 		for (i = numBits; i < sizeof(WORD) * 8; ++i)

	mov	eax, DWORD PTR _numBits$[ebp]
	mov	DWORD PTR _i$[ebp], eax
	jmp	SHORT $LN3@ExtSgn
$LN2@ExtSgn:
	mov	eax, DWORD PTR _i$[ebp]
	add	eax, 1
	mov	DWORD PTR _i$[ebp], eax
$LN3@ExtSgn:
	cmp	DWORD PTR _i$[ebp], 16			; 00000010H
	jae	SHORT $LN4@ExtSgn

; 32   : 			w |= (1 << i);

	mov	eax, 1
	mov	ecx, DWORD PTR _i$[ebp]
	shl	eax, cl
	movsx	ecx, WORD PTR _w$[ebp]
	or	ecx, eax
	mov	WORD PTR _w$[ebp], cx
	jmp	SHORT $LN2@ExtSgn
$LN4@ExtSgn:

; 33   : 
; 34   : 	return w;

	mov	ax, WORD PTR _w$[ebp]

; 35   : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ExtSgn	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _GetInfoFromByte
_TEXT	SEGMENT
_mask$ = -5						; size = 1
_hightBit$ = 8						; size = 4
_lowBit$ = 12						; size = 4
_byte$ = 16						; size = 1
_GetInfoFromByte PROC					; COMDAT

; 12   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 13   : 	unsigned char mask = 0xFE;

	mov	BYTE PTR _mask$[ebp], 254		; 000000feH

; 14   : 	mask <<= (hightBit - lowBit);

	mov	ecx, DWORD PTR _hightBit$[ebp]
	sub	ecx, DWORD PTR _lowBit$[ebp]
	mov	al, BYTE PTR _mask$[ebp]
	shl	al, cl
	mov	BYTE PTR _mask$[ebp], al

; 15   : 	mask = ~mask;

	movzx	eax, BYTE PTR _mask$[ebp]
	not	eax
	mov	BYTE PTR _mask$[ebp], al

; 16   : 	mask <<= lowBit;

	mov	al, BYTE PTR _mask$[ebp]
	mov	cl, BYTE PTR _lowBit$[ebp]
	shl	al, cl
	mov	BYTE PTR _mask$[ebp], al

; 17   : 
; 18   : 	byte &= mask;

	movzx	eax, BYTE PTR _mask$[ebp]
	movzx	ecx, BYTE PTR _byte$[ebp]
	and	ecx, eax
	mov	BYTE PTR _byte$[ebp], cl

; 19   : 	byte >>= lowBit;

	mov	al, BYTE PTR _byte$[ebp]
	mov	cl, BYTE PTR _lowBit$[ebp]
	shr	al, cl
	mov	BYTE PTR _byte$[ebp], al

; 20   : 
; 21   : 	return byte;

	mov	al, BYTE PTR _byte$[ebp]

; 22   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GetInfoFromByte ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\utility.c
;	COMDAT _GetOPCode
_TEXT	SEGMENT
_byte$ = 8						; size = 1
_GetOPCode PROC						; COMDAT

; 4    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 5    : 	byte &= 0xF8; // 1111 1000

	movzx	eax, BYTE PTR _byte$[ebp]
	and	eax, 248				; 000000f8H
	mov	BYTE PTR _byte$[ebp], al

; 6    : 	byte >>= 3;

	mov	al, BYTE PTR _byte$[ebp]
	shr	al, 3
	mov	BYTE PTR _byte$[ebp], al

; 7    : 
; 8    : 	return byte;

	mov	al, BYTE PTR _byte$[ebp]

; 9    : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_GetOPCode ENDP
_TEXT	ENDS
END
