; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.30501.0 

	TITLE	D:\Dropbox\Faks\6. semestar\SP\Projekat\VS\SP-Projekat-Repo\SP Projekat\Emulator\Instructions.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_disassembly
PUBLIC	_p
_DATA	SEGMENT
COMM	_dst:WORD
COMM	_src:WORD
COMM	_imm:WORD
COMM	_v1:WORD
COMM	_v2:WORD
COMM	_c:BYTE
COMM	_o:BYTE
COMM	_n:BYTE
COMM	_z:BYTE
_DATA	ENDS
_BSS	SEGMENT
_p	DD	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
_disassembly DB	01H
_DATA	ENDS
PUBLIC	_add
PUBLIC	_sub
PUBLIC	_mul
PUBLIC	_div
PUBLIC	_cmp
PUBLIC	_and
PUBLIC	_or
PUBLIC	_not
PUBLIC	_test
PUBLIC	_ldr
PUBLIC	_str
PUBLIC	??_C@_0BG@HHOPAAAJ@ADD?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@KAFFIPGP@SUB?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@NLOIPCMJ@MUL?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@LOLPKEDD@DIV?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@ENLMADBN@CMP?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@MLNOKKPI@AND?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0BB@COFMOLA@OR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@FMCAPLEN@NOT?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CJIPKFON@TEST?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ ; `string'
PUBLIC	??_C@_0BG@OBMAOHDJ@LDR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@KMCDCDAH@LDR?5R?$FL?$CFd?$FN?0?5PC?0?5?$CFd?6?$AA@ ; `string'
EXTRN	___report_rangecheckfailure:PROC
EXTRN	_GetPA:PROC
EXTRN	_GetInfoFromByte:PROC
EXTRN	_ExtSgn:PROC
EXTRN	_SetFlag:PROC
EXTRN	_ResetFlag:PROC
EXTRN	_GetLowerByte:PROC
EXTRN	_GetHigherByte:PROC
EXTRN	__imp__printf:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	_cpu:BYTE
EXTRN	_memory:BYTE
EXTRN	_ir0:BYTE
EXTRN	_ir1:BYTE
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_0BD@KMCDCDAH@LDR?5R?$FL?$CFd?$FN?0?5PC?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BD@KMCDCDAH@LDR?5R?$FL?$CFd?$FN?0?5PC?0?5?$CFd?6?$AA@ DB 'LDR R[%d'
	DB	'], PC, %d', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OBMAOHDJ@LDR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@OBMAOHDJ@LDR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ DB 'L'
	DB	'DR R[%d], R[%d], %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CJIPKFON@TEST?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BD@CJIPKFON@TEST?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ DB 'TEST'
	DB	' R[%d], R[%d]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@FMCAPLEN@NOT?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BC@FMCAPLEN@NOT?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ DB 'NOT R'
	DB	'[%d], R[%d]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@COFMOLA@OR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BB@COFMOLA@OR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ DB 'OR R[%d'
	DB	'], R[%d]', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@MLNOKKPI@AND?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
CONST	SEGMENT
??_C@_0BC@MLNOKKPI@AND?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@ DB 'AND R'
	DB	'[%d], R[%d]', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@ENLMADBN@CMP?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@ENLMADBN@CMP?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ DB 'C'
	DB	'MP R[%d], R[%d], %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LOLPKEDD@DIV?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@LOLPKEDD@DIV?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ DB 'D'
	DB	'IV R[%d], R[%d], %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@NLOIPCMJ@MUL?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@NLOIPCMJ@MUL?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ DB 'M'
	DB	'UL R[%d], R[%d], %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@KAFFIPGP@SUB?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@KAFFIPGP@SUB?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ DB 'S'
	DB	'UB R[%d], R[%d], %d', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HHOPAAAJ@ADD?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
CONST	SEGMENT
??_C@_0BG@HHOPAAAJ@ADD?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@ DB 'A'
	DB	'DD R[%d], R[%d], %d', 0aH, 00H		; `string'
CONST	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _str
_TEXT	SEGMENT
tv165 = -244						; size = 4
tv84 = -244						; size = 4
$T1 = -236						; size = 4
$T2 = -224						; size = 4
_addr$ = -20						; size = 2
_srcReg$ = -8						; size = 2
_str	PROC						; COMDAT

; 490  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 491  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 492  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 493  : 	imm = ExtSgn(ir0, 5);

	push	5
	movzx	eax, BYTE PTR _ir0
	push	eax
	call	_ExtSgn
	add	esp, 8
	mov	WORD PTR _imm, ax

; 494  : 
; 495  : 	REG srcReg = (src == 7) ? cpu.pc : cpu.r[src];

	movsx	eax, WORD PTR _src
	cmp	eax, 7
	jne	SHORT $LN5@str
	movsx	ecx, WORD PTR _cpu+16
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN6@str
$LN5@str:
	movsx	edx, WORD PTR _src
	movsx	eax, WORD PTR _cpu[edx*2]
	mov	DWORD PTR tv84[ebp], eax
$LN6@str:
	mov	cx, WORD PTR tv84[ebp]
	mov	WORD PTR _srcReg$[ebp], cx

; 496  : 
; 497  : 	ADDR addr = GetPA(cpu.r[dst] + imm);

	movsx	eax, WORD PTR _dst
	movsx	ecx, WORD PTR _cpu[eax*2]
	movsx	edx, WORD PTR _imm
	add	ecx, edx
	push	ecx
	call	_GetPA
	add	esp, 4
	mov	WORD PTR _addr$[ebp], ax

; 498  : 
; 499  : 	if (addr == -1)

	movzx	eax, WORD PTR _addr$[ebp]
	cmp	eax, -1
	jne	SHORT $LN2@str

; 500  : 		return 0;

	xor	al, al
	jmp	$LN4@str
$LN2@str:

; 501  : 
; 502  : 	memory[addr] = 0;

	movzx	eax, WORD PTR _addr$[ebp]
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 32768		; 00008000H
	jae	SHORT $LN7@str
	jmp	SHORT $LN8@str
$LN7@str:
	call	___report_rangecheckfailure
$LN8@str:
	mov	ecx, DWORD PTR $T1[ebp]
	mov	BYTE PTR _memory[ecx], 0

; 503  : 	memory[addr + 1] = 0;

	movzx	eax, WORD PTR _addr$[ebp]
	add	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	cmp	DWORD PTR $T2[ebp], 32768		; 00008000H
	jae	SHORT $LN9@str
	jmp	SHORT $LN10@str
$LN9@str:
	call	___report_rangecheckfailure
$LN10@str:
	mov	ecx, DWORD PTR $T2[ebp]
	mov	BYTE PTR _memory[ecx], 0

; 504  : 	memory[addr] = GetLowerByte(srcReg);

	movzx	eax, WORD PTR _srcReg$[ebp]
	push	eax
	call	_GetLowerByte
	add	esp, 4
	movzx	ecx, WORD PTR _addr$[ebp]
	mov	BYTE PTR _memory[ecx], al

; 505  : 	memory[addr + 1] = GetHigherByte(srcReg);

	movzx	eax, WORD PTR _srcReg$[ebp]
	push	eax
	call	_GetHigherByte
	add	esp, 4
	movzx	ecx, WORD PTR _addr$[ebp]
	mov	BYTE PTR _memory[ecx+1], al

; 506  : 
; 507  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN1@str

; 508  : 		(src != 7) ? printf("LDR R[%d], R[%d], %d\n", dst, src, imm) : printf("LDR R[%d], PC, %d\n", dst, imm);

	movsx	eax, WORD PTR _src
	cmp	eax, 7
	je	SHORT $LN11@str
	movsx	ecx, WORD PTR _imm
	mov	esi, esp
	push	ecx
	movsx	edx, WORD PTR _src
	push	edx
	movsx	eax, WORD PTR _dst
	push	eax
	push	OFFSET ??_C@_0BG@OBMAOHDJ@LDR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv165[ebp], eax
	jmp	SHORT $LN1@str
$LN11@str:
	movsx	ecx, WORD PTR _imm
	mov	esi, esp
	push	ecx
	movsx	edx, WORD PTR _dst
	push	edx
	push	OFFSET ??_C@_0BD@KMCDCDAH@LDR?5R?$FL?$CFd?$FN?0?5PC?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv165[ebp], eax
$LN1@str:

; 509  : 
; 510  : 	return 1;

	mov	al, 1
$LN4@str:

; 511  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_str	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _ldr
_TEXT	SEGMENT
tv175 = -220						; size = 4
tv84 = -220						; size = 4
_addr$ = -20						; size = 2
_srcReg$ = -8						; size = 2
_ldr	PROC						; COMDAT

; 467  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 468  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 469  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 470  : 	imm = ExtSgn(ir0, 5);

	push	5
	movzx	eax, BYTE PTR _ir0
	push	eax
	call	_ExtSgn
	add	esp, 8
	mov	WORD PTR _imm, ax

; 471  : 
; 472  : 	REG srcReg = (src == 7) ? cpu.pc : cpu.r[src];

	movsx	eax, WORD PTR _src
	cmp	eax, 7
	jne	SHORT $LN5@ldr
	movsx	ecx, WORD PTR _cpu+16
	mov	DWORD PTR tv84[ebp], ecx
	jmp	SHORT $LN6@ldr
$LN5@ldr:
	movsx	edx, WORD PTR _src
	movsx	eax, WORD PTR _cpu[edx*2]
	mov	DWORD PTR tv84[ebp], eax
$LN6@ldr:
	mov	cx, WORD PTR tv84[ebp]
	mov	WORD PTR _srcReg$[ebp], cx

; 473  : 
; 474  : 	ADDR addr = GetPA(srcReg + imm);

	movsx	eax, WORD PTR _srcReg$[ebp]
	movsx	ecx, WORD PTR _imm
	add	eax, ecx
	push	eax
	call	_GetPA
	add	esp, 4
	mov	WORD PTR _addr$[ebp], ax

; 475  : 
; 476  : 	if (addr == -1)

	movzx	eax, WORD PTR _addr$[ebp]
	cmp	eax, -1
	jne	SHORT $LN2@ldr

; 477  : 		return 0;

	xor	al, al
	jmp	$LN3@ldr
$LN2@ldr:

; 478  : 
; 479  : 	cpu.r[dst] = 0;

	movsx	eax, WORD PTR _dst
	xor	ecx, ecx
	mov	WORD PTR _cpu[eax*2], cx

; 480  : 	cpu.r[dst] |= memory[addr];

	movsx	eax, WORD PTR _dst
	movzx	ecx, WORD PTR _addr$[ebp]
	movsx	edx, BYTE PTR _memory[ecx]
	movsx	eax, WORD PTR _cpu[eax*2]
	or	eax, edx
	movsx	ecx, WORD PTR _dst
	mov	WORD PTR _cpu[ecx*2], ax

; 481  : 	cpu.r[dst] |= memory[addr + 1] << sizeof(REG) * 4;

	movsx	eax, WORD PTR _dst
	movzx	ecx, WORD PTR _addr$[ebp]
	movsx	edx, BYTE PTR _memory[ecx+1]
	shl	edx, 8
	movsx	eax, WORD PTR _cpu[eax*2]
	or	eax, edx
	movsx	ecx, WORD PTR _dst
	mov	WORD PTR _cpu[ecx*2], ax

; 482  : 
; 483  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN1@ldr

; 484  : 		(src != 7) ? printf("LDR R[%d], R[%d], %d\n", dst, src, imm) : printf("LDR R[%d], PC, %d\n", dst, imm);

	movsx	eax, WORD PTR _src
	cmp	eax, 7
	je	SHORT $LN7@ldr
	movsx	ecx, WORD PTR _imm
	mov	esi, esp
	push	ecx
	movsx	edx, WORD PTR _src
	push	edx
	movsx	eax, WORD PTR _dst
	push	eax
	push	OFFSET ??_C@_0BG@OBMAOHDJ@LDR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv175[ebp], eax
	jmp	SHORT $LN1@ldr
$LN7@ldr:
	movsx	ecx, WORD PTR _imm
	mov	esi, esp
	push	ecx
	movsx	edx, WORD PTR _dst
	push	edx
	push	OFFSET ??_C@_0BD@KMCDCDAH@LDR?5R?$FL?$CFd?$FN?0?5PC?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR tv175[ebp], eax
$LN1@ldr:

; 485  : 
; 486  : 	return 1;

	mov	al, 1
$LN3@ldr:

; 487  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_ldr	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _test
_TEXT	SEGMENT
_test	PROC						; COMDAT

; 434  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 435  : 	c = 0, n = 0, z = 0, o = 0;

	mov	BYTE PTR _c, 0
	mov	BYTE PTR _n, 0
	mov	BYTE PTR _z, 0
	mov	BYTE PTR _o, 0

; 436  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 437  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 438  : 	v1 = cpu.r[dst];

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v1, cx

; 439  : 	v2 = cpu.r[src];

	movsx	eax, WORD PTR _src
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v2, cx

; 440  : 
; 441  : #ifdef _WIN32
; 442  : 	__asm
; 443  : 	{
; 444  : 		push ax;

	push	ax

; 445  : 		mov ax, v1;

	mov	ax, WORD PTR _v1

; 446  : 		and ax, v2;

	and	ax, WORD PTR _v2

; 447  : 		pop ax;

	pop	ax

; 448  : 		jno l1;

	jno	SHORT $l1$12

; 449  : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l1$12:

; 450  : 	l1: jnc l2;

	jae	SHORT $l2$13

; 451  : 		mov c, 1;

	mov	BYTE PTR _c, 1
$l2$13:

; 452  : 	l2: jns l3;

	jns	SHORT $l3$14

; 453  : 		mov n, 1;

	mov	BYTE PTR _n, 1
$l3$14:

; 454  : 	l3: jnz l4;

	jne	SHORT $l4$15

; 455  : 		mov z, 1;

	mov	BYTE PTR _z, 1
$l4$15:

; 456  : 	l4:;
; 457  : 	}
; 458  : #endif
; 459  : 
; 460  : 	UPDATE_ALL_FLAGS;

	movzx	eax, BYTE PTR _z
	test	eax, eax
	je	SHORT $LN9@test
	push	0
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN8@test
$LN9@test:
	push	0
	call	_ResetFlag
	add	esp, 4
$LN8@test:
	movzx	eax, BYTE PTR _n
	test	eax, eax
	je	SHORT $LN7@test
	push	3
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN6@test
$LN7@test:
	push	3
	call	_ResetFlag
	add	esp, 4
$LN6@test:
	movzx	eax, BYTE PTR _c
	test	eax, eax
	je	SHORT $LN5@test
	push	2
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN4@test
$LN5@test:
	push	2
	call	_ResetFlag
	add	esp, 4
$LN4@test:
	movzx	eax, BYTE PTR _o
	test	eax, eax
	je	SHORT $LN3@test
	push	1
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN2@test
$LN3@test:
	push	1
	call	_ResetFlag
	add	esp, 4
$LN2@test:

; 461  : 
; 462  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN10@test

; 463  : 		printf("TEST R[%d], R[%d]\n", dst, src);

	movsx	eax, WORD PTR _src
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _dst
	push	ecx
	push	OFFSET ??_C@_0BD@CJIPKFON@TEST?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@test:

; 464  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_test	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _not
_TEXT	SEGMENT
_not	PROC						; COMDAT

; 399  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 400  : 	c = 0, n = 0, z = 0, o = 0;

	mov	BYTE PTR _c, 0
	mov	BYTE PTR _n, 0
	mov	BYTE PTR _z, 0
	mov	BYTE PTR _o, 0

; 401  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 402  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 403  : 	v1 = cpu.r[src];

	movsx	eax, WORD PTR _src
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v1, cx

; 404  : 
; 405  : #ifdef _WIN32
; 406  : 	__asm
; 407  : 	{
; 408  : 		push ax;

	push	ax

; 409  : 		mov ax, v1;

	mov	ax, WORD PTR _v1

; 410  : 		not ax;

	not	ax

; 411  : 		mov v1, ax;

	mov	WORD PTR _v1, ax

; 412  : 		pop ax;

	pop	ax

; 413  : 		jno l1;

	jno	SHORT $l1$12

; 414  : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l1$12:

; 415  : 	l1: jnc l2;

	jae	SHORT $l2$13

; 416  : 		mov c, 1;

	mov	BYTE PTR _c, 1
$l2$13:

; 417  : 	l2: jns l3;

	jns	SHORT $l3$14

; 418  : 		mov n, 1;

	mov	BYTE PTR _n, 1
$l3$14:

; 419  : 	l3: jnz l4;

	jne	SHORT $l4$15

; 420  : 		mov z, 1;

	mov	BYTE PTR _z, 1
$l4$15:

; 421  : 	l4:;
; 422  : 	}
; 423  : #endif
; 424  : 
; 425  : 	cpu.r[dst] = v1;

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _v1
	mov	WORD PTR _cpu[eax*2], cx

; 426  : 
; 427  : 	UPDATE_ALL_FLAGS;

	movzx	eax, BYTE PTR _z
	test	eax, eax
	je	SHORT $LN9@not
	push	0
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN8@not
$LN9@not:
	push	0
	call	_ResetFlag
	add	esp, 4
$LN8@not:
	movzx	eax, BYTE PTR _n
	test	eax, eax
	je	SHORT $LN7@not
	push	3
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN6@not
$LN7@not:
	push	3
	call	_ResetFlag
	add	esp, 4
$LN6@not:
	movzx	eax, BYTE PTR _c
	test	eax, eax
	je	SHORT $LN5@not
	push	2
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN4@not
$LN5@not:
	push	2
	call	_ResetFlag
	add	esp, 4
$LN4@not:
	movzx	eax, BYTE PTR _o
	test	eax, eax
	je	SHORT $LN3@not
	push	1
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN2@not
$LN3@not:
	push	1
	call	_ResetFlag
	add	esp, 4
$LN2@not:

; 428  : 
; 429  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN10@not

; 430  : 		printf("NOT R[%d], R[%d]\n", dst, src);

	movsx	eax, WORD PTR _src
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _dst
	push	ecx
	push	OFFSET ??_C@_0BC@FMCAPLEN@NOT?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@not:

; 431  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_not	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _or
_TEXT	SEGMENT
_or	PROC						; COMDAT

; 363  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 364  : 	c = 0, n = 0, z = 0, o = 0;

	mov	BYTE PTR _c, 0
	mov	BYTE PTR _n, 0
	mov	BYTE PTR _z, 0
	mov	BYTE PTR _o, 0

; 365  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 366  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 367  : 	v1 = cpu.r[dst];

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v1, cx

; 368  : 	v2 = cpu.r[src];

	movsx	eax, WORD PTR _src
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v2, cx

; 369  : 
; 370  : #ifdef _WIN32
; 371  : 	__asm
; 372  : 	{
; 373  : 		push ax;

	push	ax

; 374  : 		mov ax, v1;

	mov	ax, WORD PTR _v1

; 375  : 		or ax, v2;

	or	ax, WORD PTR _v2

; 376  : 		mov v1, ax;

	mov	WORD PTR _v1, ax

; 377  : 		pop ax;

	pop	ax

; 378  : 		jno l1;

	jno	SHORT $l1$12

; 379  : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l1$12:

; 380  : 	l1: jnc l2;

	jae	SHORT $l2$13

; 381  : 		mov c, 1;

	mov	BYTE PTR _c, 1
$l2$13:

; 382  : 	l2: jns l3;

	jns	SHORT $l3$14

; 383  : 		mov n, 1;

	mov	BYTE PTR _n, 1
$l3$14:

; 384  : 	l3: jnz l4;

	jne	SHORT $l4$15

; 385  : 		mov z, 1;

	mov	BYTE PTR _z, 1
$l4$15:

; 386  : 	l4:;
; 387  : 	}
; 388  : #endif
; 389  : 
; 390  : 	cpu.r[dst] = v1;

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _v1
	mov	WORD PTR _cpu[eax*2], cx

; 391  : 
; 392  : 	UPDATE_ALL_FLAGS;

	movzx	eax, BYTE PTR _z
	test	eax, eax
	je	SHORT $LN9@or
	push	0
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN8@or
$LN9@or:
	push	0
	call	_ResetFlag
	add	esp, 4
$LN8@or:
	movzx	eax, BYTE PTR _n
	test	eax, eax
	je	SHORT $LN7@or
	push	3
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN6@or
$LN7@or:
	push	3
	call	_ResetFlag
	add	esp, 4
$LN6@or:
	movzx	eax, BYTE PTR _c
	test	eax, eax
	je	SHORT $LN5@or
	push	2
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN4@or
$LN5@or:
	push	2
	call	_ResetFlag
	add	esp, 4
$LN4@or:
	movzx	eax, BYTE PTR _o
	test	eax, eax
	je	SHORT $LN3@or
	push	1
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN2@or
$LN3@or:
	push	1
	call	_ResetFlag
	add	esp, 4
$LN2@or:

; 393  : 
; 394  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN10@or

; 395  : 		printf("OR R[%d], R[%d]\n", dst, src);

	movsx	eax, WORD PTR _src
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _dst
	push	ecx
	push	OFFSET ??_C@_0BB@COFMOLA@OR?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@or:

; 396  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_or	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _and
_TEXT	SEGMENT
_and	PROC						; COMDAT

; 327  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 328  : 	c = 0, n = 0, z = 0, o = 0;

	mov	BYTE PTR _c, 0
	mov	BYTE PTR _n, 0
	mov	BYTE PTR _z, 0
	mov	BYTE PTR _o, 0

; 329  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 330  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 331  : 	v1 = cpu.r[dst];

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v1, cx

; 332  : 	v2 = cpu.r[src];

	movsx	eax, WORD PTR _src
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v2, cx

; 333  : 
; 334  : #ifdef _WIN32
; 335  : 	__asm
; 336  : 	{
; 337  : 		push ax;

	push	ax

; 338  : 		mov ax, v1;

	mov	ax, WORD PTR _v1

; 339  : 		and ax, v2;

	and	ax, WORD PTR _v2

; 340  : 		mov v1, ax;

	mov	WORD PTR _v1, ax

; 341  : 		pop ax;

	pop	ax

; 342  : 	jno l1;

	jno	SHORT $l1$12

; 343  : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l1$12:

; 344  : 	l1: jnc l2;

	jae	SHORT $l2$13

; 345  : 		mov c, 1;

	mov	BYTE PTR _c, 1
$l2$13:

; 346  : 	l2: jns l3;

	jns	SHORT $l3$14

; 347  : 		mov n, 1;

	mov	BYTE PTR _n, 1
$l3$14:

; 348  : 	l3: jnz l4;

	jne	SHORT $l4$15

; 349  : 		mov z, 1;

	mov	BYTE PTR _z, 1
$l4$15:

; 350  : 	l4:;
; 351  : 	}
; 352  : #endif
; 353  : 
; 354  : 	cpu.r[dst] = v1;

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _v1
	mov	WORD PTR _cpu[eax*2], cx

; 355  : 
; 356  : 	UPDATE_ALL_FLAGS;

	movzx	eax, BYTE PTR _z
	test	eax, eax
	je	SHORT $LN9@and
	push	0
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN8@and
$LN9@and:
	push	0
	call	_ResetFlag
	add	esp, 4
$LN8@and:
	movzx	eax, BYTE PTR _n
	test	eax, eax
	je	SHORT $LN7@and
	push	3
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN6@and
$LN7@and:
	push	3
	call	_ResetFlag
	add	esp, 4
$LN6@and:
	movzx	eax, BYTE PTR _c
	test	eax, eax
	je	SHORT $LN5@and
	push	2
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN4@and
$LN5@and:
	push	2
	call	_ResetFlag
	add	esp, 4
$LN4@and:
	movzx	eax, BYTE PTR _o
	test	eax, eax
	je	SHORT $LN3@and
	push	1
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN2@and
$LN3@and:
	push	1
	call	_ResetFlag
	add	esp, 4
$LN2@and:

; 357  : 	
; 358  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN10@and

; 359  : 		printf("AND R[%d], R[%d]\n", dst, src);

	movsx	eax, WORD PTR _src
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _dst
	push	ecx
	push	OFFSET ??_C@_0BC@MLNOKKPI@AND?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@and:

; 360  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_and	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _cmp
_TEXT	SEGMENT
_cmp	PROC						; COMDAT

; 291  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 292  : 	c = 0, o = 0, n = 0, z = 0;

	mov	BYTE PTR _c, 0
	mov	BYTE PTR _o, 0
	mov	BYTE PTR _n, 0
	mov	BYTE PTR _z, 0

; 293  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 294  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 295  : 	imm = ExtSgn(ir0, 5);

	push	5
	movzx	eax, BYTE PTR _ir0
	push	eax
	call	_ExtSgn
	add	esp, 8
	mov	WORD PTR _imm, ax

; 296  : 
; 297  : 	v1 = cpu.r[dst];

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v1, cx

; 298  : 	v2 = cpu.r[src];

	movsx	eax, WORD PTR _src
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v2, cx

; 299  : 
; 300  : #ifdef _WIN32
; 301  : 	__asm
; 302  : 	{
; 303  : 		push ax;

	push	ax

; 304  : 		mov ax, imm;

	mov	ax, WORD PTR _imm

; 305  : 		add ax, v2;

	add	ax, WORD PTR _v2

; 306  : 		cmp v1, ax;

	cmp	WORD PTR _v1, ax

; 307  : 		pop ax;

	pop	ax

; 308  : 		jno l1;

	jno	SHORT $l1$12

; 309  : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l1$12:

; 310  : 	l1: jnc l2;

	jae	SHORT $l2$13

; 311  : 		mov c, 1;

	mov	BYTE PTR _c, 1
$l2$13:

; 312  : 	l2: jns l3;

	jns	SHORT $l3$14

; 313  : 		mov n, 1;

	mov	BYTE PTR _n, 1
$l3$14:

; 314  : 	l3: jnz l4;

	jne	SHORT $l4$15

; 315  : 		mov z, 1;

	mov	BYTE PTR _z, 1
$l4$15:

; 316  : 	l4:;
; 317  : 	}
; 318  : #endif // _WIN32
; 319  : 
; 320  : 	UPDATE_ALL_FLAGS;

	movzx	eax, BYTE PTR _z
	test	eax, eax
	je	SHORT $LN9@cmp
	push	0
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN8@cmp
$LN9@cmp:
	push	0
	call	_ResetFlag
	add	esp, 4
$LN8@cmp:
	movzx	eax, BYTE PTR _n
	test	eax, eax
	je	SHORT $LN7@cmp
	push	3
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN6@cmp
$LN7@cmp:
	push	3
	call	_ResetFlag
	add	esp, 4
$LN6@cmp:
	movzx	eax, BYTE PTR _c
	test	eax, eax
	je	SHORT $LN5@cmp
	push	2
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN4@cmp
$LN5@cmp:
	push	2
	call	_ResetFlag
	add	esp, 4
$LN4@cmp:
	movzx	eax, BYTE PTR _o
	test	eax, eax
	je	SHORT $LN3@cmp
	push	1
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN2@cmp
$LN3@cmp:
	push	1
	call	_ResetFlag
	add	esp, 4
$LN2@cmp:

; 321  : 
; 322  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN10@cmp

; 323  : 		printf("CMP R[%d], R[%d], %d\n", dst, src, imm);

	movsx	eax, WORD PTR _imm
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _src
	push	ecx
	movsx	edx, WORD PTR _dst
	push	edx
	push	OFFSET ??_C@_0BG@ENLMADBN@CMP?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@cmp:

; 324  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_cmp	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _div
_TEXT	SEGMENT
_div	PROC						; COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 270  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 271  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 272  : 	imm = ExtSgn(ir0, 5);

	push	5
	movzx	eax, BYTE PTR _ir0
	push	eax
	call	_ExtSgn
	add	esp, 8
	mov	WORD PTR _imm, ax

; 273  : 
; 274  : 	cpu.r[dst] /= cpu.r[src] / imm;

	movsx	ecx, WORD PTR _dst
	movsx	edx, WORD PTR _src
	movsx	eax, WORD PTR _cpu[edx*2]
	movsx	esi, WORD PTR _imm
	cdq
	idiv	esi
	mov	esi, eax
	movsx	eax, WORD PTR _cpu[ecx*2]
	cdq
	idiv	esi
	movsx	ecx, WORD PTR _dst
	mov	WORD PTR _cpu[ecx*2], ax

; 275  : 
; 276  : 	if (cpu.r[dst] == 0)

	movsx	eax, WORD PTR _dst
	movsx	ecx, WORD PTR _cpu[eax*2]
	test	ecx, ecx
	jne	SHORT $LN5@div

; 277  : 		SetFlag(Z);

	push	0
	call	_SetFlag
	add	esp, 4

; 278  : 	else

	jmp	SHORT $LN4@div
$LN5@div:

; 279  : 		ResetFlag(Z);

	push	0
	call	_ResetFlag
	add	esp, 4
$LN4@div:

; 280  : 
; 281  : 	if (cpu.r[dst] < 0)

	movsx	eax, WORD PTR _dst
	movsx	ecx, WORD PTR _cpu[eax*2]
	test	ecx, ecx
	jge	SHORT $LN3@div

; 282  : 		SetFlag(N);

	push	3
	call	_SetFlag
	add	esp, 4

; 283  : 	else

	jmp	SHORT $LN2@div
$LN3@div:

; 284  : 		ResetFlag(N);

	push	3
	call	_ResetFlag
	add	esp, 4
$LN2@div:

; 285  : 
; 286  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN6@div

; 287  : 		printf("DIV R[%d], R[%d], %d\n", dst, src, imm);

	movsx	eax, WORD PTR _imm
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _src
	push	ecx
	movsx	edx, WORD PTR _dst
	push	edx
	push	OFFSET ??_C@_0BG@LOLPKEDD@DIV?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@div:

; 288  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_div	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _mul
_TEXT	SEGMENT
_mul	PROC						; COMDAT

; 252  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 253  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 254  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 255  : 	imm = ExtSgn(ir0, 5);

	push	5
	movzx	eax, BYTE PTR _ir0
	push	eax
	call	_ExtSgn
	add	esp, 8
	mov	WORD PTR _imm, ax

; 256  : 
; 257  : 	cpu.r[dst] *= cpu.r[src] * imm;

	movsx	eax, WORD PTR _dst
	movsx	ecx, WORD PTR _src
	movsx	edx, WORD PTR _cpu[ecx*2]
	movsx	ecx, WORD PTR _imm
	imul	edx, ecx
	movsx	eax, WORD PTR _cpu[eax*2]
	imul	eax, edx
	movsx	ecx, WORD PTR _dst
	mov	WORD PTR _cpu[ecx*2], ax

; 258  : 
; 259  : 	if (cpu.r[dst] == 0)

	movsx	eax, WORD PTR _dst
	movsx	ecx, WORD PTR _cpu[eax*2]
	test	ecx, ecx
	jne	SHORT $LN3@mul

; 260  : 		SetFlag(Z);

	push	0
	call	_SetFlag
	add	esp, 4
$LN3@mul:

; 261  : 	if (cpu.r[dst] < 0)

	movsx	eax, WORD PTR _dst
	movsx	ecx, WORD PTR _cpu[eax*2]
	test	ecx, ecx
	jge	SHORT $LN2@mul

; 262  : 		SetFlag(N);

	push	3
	call	_SetFlag
	add	esp, 4
$LN2@mul:

; 263  : 
; 264  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN4@mul

; 265  : 		printf("MUL R[%d], R[%d], %d\n", dst, src, imm);

	movsx	eax, WORD PTR _imm
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _src
	push	ecx
	movsx	edx, WORD PTR _dst
	push	edx
	push	OFFSET ??_C@_0BG@NLOIPCMJ@MUL?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@mul:

; 266  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_mul	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _sub
_TEXT	SEGMENT
_sub	PROC						; COMDAT

; 141  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 142  : 	c = 0, n = 0, z = 0, o = 0;

	mov	BYTE PTR _c, 0
	mov	BYTE PTR _n, 0
	mov	BYTE PTR _z, 0
	mov	BYTE PTR _o, 0

; 143  : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 144  : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 145  : 	imm = ExtSgn(ir0, 5);

	push	5
	movzx	eax, BYTE PTR _ir0
	push	eax
	call	_ExtSgn
	add	esp, 8
	mov	WORD PTR _imm, ax

; 146  : 
; 147  : 	v1 = cpu.r[dst];

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v1, cx

; 148  : 	v2 = cpu.r[src];

	movsx	eax, WORD PTR _src
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v2, cx

; 149  : 
; 150  : #ifdef _WIN32
; 151  : 	// oduzimanje druga dva sabirka i provera za overflow i carry
; 152  : 
; 153  : 	__asm
; 154  : 	{
; 155  : 		push ax;

	push	ax

; 156  : 		mov ax, v2;

	mov	ax, WORD PTR _v2

; 157  : 		add ax, imm;

	add	ax, WORD PTR _imm

; 158  : 		mov v2, ax;

	mov	WORD PTR _v2, ax

; 159  : 		pop ax;

	pop	ax

; 160  : 		jno l1;

	jno	SHORT $l1$12

; 161  : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l1$12:

; 162  : 	l1: jnc l2;

	jae	SHORT $l2$13

; 163  : 		mov c, 1

	mov	BYTE PTR _c, 1
$l2$13:

; 164  : 		l2:;
; 165  : 	}
; 166  : 
; 167  : 	// oduzimanje destinacije i prethodnog zbira i provera za oveflow i carry
; 168  : 
; 169  : 	__asm
; 170  : 	{
; 171  : 		push ax;

	push	ax

; 172  : 		mov ax, v1;

	mov	ax, WORD PTR _v1

; 173  : 		sub ax, v2;

	sub	ax, WORD PTR _v2

; 174  : 		mov v1, ax;

	mov	WORD PTR _v1, ax

; 175  : 		pop ax;

	pop	ax

; 176  : 		jno l11;

	jno	SHORT $l11$14

; 177  : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l11$14:

; 178  : 	l11: jnc l22;

	jae	SHORT $l22$15

; 179  : 		mov c, 1;

	mov	BYTE PTR _c, 1
$l22$15:

; 180  : 	l22: jns l33;

	jns	SHORT $l33$16

; 181  : 		mov n, 1;

	mov	BYTE PTR _n, 1
$l33$16:

; 182  : 	l33: jnz l44;

	jne	SHORT $l44$17

; 183  : 		mov z, 1;

	mov	BYTE PTR _z, 1
$l44$17:

; 184  : 	l44:;
; 185  : 	}
; 186  : 
; 187  : #else
; 188  : #ifdef __gnu_linux__
; 189  : 
; 190  : 	__asm__
; 191  : 		(
; 192  : 		"mov ax, %5\n"
; 193  : 		"add ax, %4\n"
; 194  : 		"mov %0, ax\n"
; 195  : 		"jno l1s\n"
; 196  : 		"pushf\n"
; 197  : 		"mov al, %2\n"
; 198  : 		"inc al\n"
; 199  : 		"mov %2, al\n"
; 200  : 		"popf\n"
; 201  : 		"l1s : jnc l2s\n"
; 202  : 		"pushf\n"
; 203  : 		"mov al, %1\n"
; 204  : 		"inc al\n"
; 205  : 		"mov %1, al\n"
; 206  : 		"popf\n"
; 207  : 		"l2s:\n"
; 208  : 		:"=m"(v2), "=m"(carry), "=m"(overflow)
; 209  : 		: "m"(v1), "m"(imm), "m"(v2)
; 210  : 		: "ax", "al"
; 211  : 		);
; 212  : 
; 213  : 	// oduzimanje destinacije i prethodnog zbira i provera za oveflow i carry
; 214  : 
; 215  : 	__asm__
; 216  : 		(
; 217  : 		"mov ax, %3\n"
; 218  : 		"sub ax, %4\n"
; 219  : 		"mov %0, ax\n"
; 220  : 		"jno l11s\n"
; 221  : 		"pushf\n"
; 222  : 		"mov al, %2\n"
; 223  : 		"inc al\n"
; 224  : 		"mov %2, al\n"
; 225  : 		"popf\n"
; 226  : 		"l11s: jnc l22s\n"
; 227  : 		"pushf\n"
; 228  : 		"mov al, %1\n"
; 229  : 		"inc al\n"
; 230  : 		"mov %1, al\n"
; 231  : 		"popf\n"
; 232  : 		"l22s:\n"
; 233  : 		:"=m"(v1), "=m"(carry), "=m"(overflow)
; 234  : 		: "m"(v1), "m"(v2)
; 235  : 		: "ax", "al"
; 236  : 		);
; 237  : 
; 238  : #endif
; 239  : #endif
; 240  : 
; 241  : 	cpu.r[dst] = v1;

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _v1
	mov	WORD PTR _cpu[eax*2], cx

; 242  : 
; 243  : 	// **** Setovanje flegova ****
; 244  : 
; 245  : 	UPDATE_ALL_FLAGS;

	movzx	eax, BYTE PTR _z
	test	eax, eax
	je	SHORT $LN9@sub
	push	0
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN8@sub
$LN9@sub:
	push	0
	call	_ResetFlag
	add	esp, 4
$LN8@sub:
	movzx	eax, BYTE PTR _n
	test	eax, eax
	je	SHORT $LN7@sub
	push	3
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN6@sub
$LN7@sub:
	push	3
	call	_ResetFlag
	add	esp, 4
$LN6@sub:
	movzx	eax, BYTE PTR _c
	test	eax, eax
	je	SHORT $LN5@sub
	push	2
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN4@sub
$LN5@sub:
	push	2
	call	_ResetFlag
	add	esp, 4
$LN4@sub:
	movzx	eax, BYTE PTR _o
	test	eax, eax
	je	SHORT $LN3@sub
	push	1
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN2@sub
$LN3@sub:
	push	1
	call	_ResetFlag
	add	esp, 4
$LN2@sub:

; 246  : 
; 247  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN10@sub

; 248  : 		printf("SUB R[%d], R[%d], %d\n", dst, src, imm);

	movsx	eax, WORD PTR _imm
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _src
	push	ecx
	movsx	edx, WORD PTR _dst
	push	edx
	push	OFFSET ??_C@_0BG@KAFFIPGP@SUB?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@sub:

; 249  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_sub	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File d:\dropbox\faks\6. semestar\sp\projekat\vs\sp-projekat-repo\sp projekat\emulator\instructions.c
;	COMDAT _add
_TEXT	SEGMENT
_add	PROC						; COMDAT

; 32   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 33   : 	c = 0, o = 0, n = 0, z = 0;

	mov	BYTE PTR _c, 0
	mov	BYTE PTR _o, 0
	mov	BYTE PTR _n, 0
	mov	BYTE PTR _z, 0

; 34   : 	dst = GetInfoFromByte(2, 0, ir1);

	movzx	eax, BYTE PTR _ir1
	push	eax
	push	0
	push	2
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _dst, cx

; 35   : 	src = GetInfoFromByte(7, 5, ir0);

	movzx	eax, BYTE PTR _ir0
	push	eax
	push	5
	push	7
	call	_GetInfoFromByte
	add	esp, 12					; 0000000cH
	movzx	cx, al
	mov	WORD PTR _src, cx

; 36   : 	imm = ExtSgn(ir0, 5);

	push	5
	movzx	eax, BYTE PTR _ir0
	push	eax
	call	_ExtSgn
	add	esp, 8
	mov	WORD PTR _imm, ax

; 37   : 
; 38   : 
; 39   : 	v1 = cpu.r[dst];

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v1, cx

; 40   : 	v2 = cpu.r[src];

	movsx	eax, WORD PTR _src
	mov	cx, WORD PTR _cpu[eax*2]
	mov	WORD PTR _v2, cx

; 41   : 
; 42   : #ifdef _WIN32
; 43   : 	// sabiranje druga dva sabirka i provera za overflow i carry
; 44   : 	__asm
; 45   : 	{
; 46   : 		push ax;

	push	ax

; 47   : 		mov ax, v2;

	mov	ax, WORD PTR _v2

; 48   : 		add ax, imm;

	add	ax, WORD PTR _imm

; 49   : 		mov v2, ax;

	mov	WORD PTR _v2, ax

; 50   : 		pop ax;

	pop	ax

; 51   : 		jno l1;

	jno	SHORT $l1$12

; 52   : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l1$12:

; 53   : 	l1: jnc l2;

	jae	SHORT $l2$13

; 54   : 		mov c, 1

	mov	BYTE PTR _c, 1
$l2$13:

; 55   : 		l2:;
; 56   : 	}
; 57   : 
; 58   : 	// sabiranje destinacije i prethodnog zbira i provera za oveflow i carry
; 59   : 	__asm
; 60   : 	{
; 61   : 		push ax;

	push	ax

; 62   : 		mov ax, v1;

	mov	ax, WORD PTR _v1

; 63   : 		add ax, v2;

	add	ax, WORD PTR _v2

; 64   : 		mov v1, ax

	mov	WORD PTR _v1, ax

; 65   : 		pop ax;

	pop	ax

; 66   : 		jno l11;

	jno	SHORT $l11$14

; 67   : 		mov o, 1;

	mov	BYTE PTR _o, 1
$l11$14:

; 68   : 	l11: jnc l22;

	jae	SHORT $l22$15

; 69   : 		mov c, 1;

	mov	BYTE PTR _c, 1
$l22$15:

; 70   : 	l22: jns l33;

	jns	SHORT $l33$16

; 71   : 		mov n, 1;

	mov	BYTE PTR _n, 1
$l33$16:

; 72   : 	l33: jnz l44;

	jne	SHORT $l44$17

; 73   : 		mov z, 1;

	mov	BYTE PTR _z, 1
$l44$17:

; 74   : 	l44:;
; 75   : 	}
; 76   : 
; 77   : #else
; 78   : #ifdef __gnu_linux__
; 79   : 	// sabiranje druga dva sabirka i provera za overflow i carry
; 80   : 	__asm__
; 81   : 		(
; 82   : 		"mov ax, %5\n"
; 83   : 		"add ax, %4\n"
; 84   : 		"mov %0, ax\n"
; 85   : 		"jno l1\n"
; 86   : 		"pushf\n"
; 87   : 		"mov al, %2\n"
; 88   : 		"inc al\n"
; 89   : 		"mov %2, al\n"
; 90   : 		"popf\n"
; 91   : 		"l1 : jnc l2\n"
; 92   : 		"pushf\n"
; 93   : 		"mov al, %1\n"
; 94   : 		"inc al\n"
; 95   : 		"mov %1, al\n"
; 96   : 		"popf\n"
; 97   : 		"l2:\n"
; 98   : 		:"=m"(v2), "=m"(carry), "=m"(overflow)
; 99   : 		: "m"(v1), "m"(imm), "m"(v2)
; 100  : 		: "ax", "al"
; 101  : 		);
; 102  : 
; 103  : 	// sabiranje destinacije i prethodnog zbira i provera za oveflow i carry
; 104  : 	__asm__
; 105  : 		(
; 106  : 		"mov ax, %3\n"
; 107  : 		"add ax, %4\n"
; 108  : 		"mov %0, ax\n"
; 109  : 		"jno l11\n"
; 110  : 		"pushf\n"
; 111  : 		"mov al, %2\n"
; 112  : 		"inc al\n"
; 113  : 		"mov %2, al\n"
; 114  : 		"popf\n"
; 115  : 		"l11: jnc l22\n"
; 116  : 		"pushf\n"
; 117  : 		"mov al, %1\n"
; 118  : 		"inc al\n"
; 119  : 		"mov %1, al\n"
; 120  : 		"popf\n"
; 121  : 		"l22:\n"
; 122  : 		:"=m"(v1), "=m"(carry), "=m"(overflow)
; 123  : 		: "m"(v1), "m"(v2)
; 124  : 		: "ax", "al"
; 125  : 		);
; 126  : 
; 127  : #endif
; 128  : #endif
; 129  : 
; 130  : 	cpu.r[dst] = v1;

	movsx	eax, WORD PTR _dst
	mov	cx, WORD PTR _v1
	mov	WORD PTR _cpu[eax*2], cx

; 131  : 
; 132  : 	UPDATE_ALL_FLAGS;

	movzx	eax, BYTE PTR _z
	test	eax, eax
	je	SHORT $LN9@add
	push	0
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN8@add
$LN9@add:
	push	0
	call	_ResetFlag
	add	esp, 4
$LN8@add:
	movzx	eax, BYTE PTR _n
	test	eax, eax
	je	SHORT $LN7@add
	push	3
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN6@add
$LN7@add:
	push	3
	call	_ResetFlag
	add	esp, 4
$LN6@add:
	movzx	eax, BYTE PTR _c
	test	eax, eax
	je	SHORT $LN5@add
	push	2
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN4@add
$LN5@add:
	push	2
	call	_ResetFlag
	add	esp, 4
$LN4@add:
	movzx	eax, BYTE PTR _o
	test	eax, eax
	je	SHORT $LN3@add
	push	1
	call	_SetFlag
	add	esp, 4
	jmp	SHORT $LN2@add
$LN3@add:
	push	1
	call	_ResetFlag
	add	esp, 4
$LN2@add:

; 133  : 
; 134  : 	if (disassembly)

	movzx	eax, BYTE PTR _disassembly
	test	eax, eax
	je	SHORT $LN10@add

; 135  : 		printf("ADD R[%d], R[%d], %d\n", dst, src, imm);

	movsx	eax, WORD PTR _imm
	mov	esi, esp
	push	eax
	movsx	ecx, WORD PTR _src
	push	ecx
	movsx	edx, WORD PTR _dst
	push	edx
	push	OFFSET ??_C@_0BG@HHOPAAAJ@ADD?5R?$FL?$CFd?$FN?0?5R?$FL?$CFd?$FN?0?5?$CFd?6?$AA@
	call	DWORD PTR __imp__printf
	add	esp, 16					; 00000010H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN10@add:

; 136  : 
; 137  : 
; 138  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_add	ENDP
_TEXT	ENDS
END
